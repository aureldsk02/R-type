<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-TYPE: Case Study Comparative : Selection of Libraries and Algorithms for R-TYPE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">R-TYPE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Case Study Comparative : Selection of Libraries and Algorithms for R-TYPE</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md18"></a> </p>
<h1><a class="anchor" id="autotoc_md19"></a>
Executive Summary</h1>
<p>This document presents the comparative analysis that led to the selection of the libraries and algorithms for our R-TYPE project. This strategic decision is based on a rigorous evaluation of technical, performance, and long-term maintainability criteria. We prioritize cross-platform tools.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md21"></a>
Table of Contents</h1>
<ol type="1">
<li>Project Context</li>
<li>Evaluation Methodology</li>
<li>Graphics Library Comparison</li>
<li>Networking Library Comparison</li>
<li>Entity Component System (ECS) Architecture</li>
<li>Database Choice for User Management</li>
<li>Cryptography Library Comparison</li>
<li>Configuration Management</li>
<li>Testing Framework</li>
<li>Algorithms, Data Structures And Design Patterns</li>
<li>Risk Assessment</li>
<li>Conclusion</li>
<li>Appendices</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md23"></a>
1. Project Context</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
1.1 Project Overview</h2>
<ul>
<li><b>Project Name</b>: R-TYPE</li>
<li><b>Type</b>: Multiplayer shoot'em up game</li>
<li><b>Target Platform</b>: Linux, Windows, macOS</li>
<li><b>Team Size</b>: 4 developers</li>
<li><b>Development Timeline</b>: 7 weeks</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
1.2 Technical Requirements</h2>
<ul>
<li>Real-time multiplayer networking (UDP)</li>
<li>2D graphics rendering with sprite animation</li>
<li>Entity Component System architecture</li>
<li>Cross-platform compatibility</li>
<li>Configuration file management</li>
<li>Unit testing capabilities</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
1.3 Constraints</h2>
<ul>
<li><b>Performance</b>: 60 FPS minimum</li>
<li><b>Latency</b>: &lt; 100ms for network operations</li>
<li><b>Memory</b>: Efficient memory management</li>
<li><b>Deployment</b>: Easy build and distribution</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md28"></a>
2. Evaluation Methodology</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
2.1 Selection Criteria</h2>
<p>Each library was evaluated based on:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Criterion   </th><th class="markdownTableHeadNone">Weight   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Performance</b>   </td><td class="markdownTableBodyNone">30%   </td><td class="markdownTableBodyNone">Execution speed, memory usage, FPS impact    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Cross-platform</b>   </td><td class="markdownTableBodyNone">30%   </td><td class="markdownTableBodyNone">Linux, Windows, macOS support    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Documentation</b>   </td><td class="markdownTableBodyNone">15%   </td><td class="markdownTableBodyNone">Quality and completeness of documentation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Learning Curve</b>   </td><td class="markdownTableBodyNone">15%   </td><td class="markdownTableBodyNone">Time to productive development    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>License</b>   </td><td class="markdownTableBodyNone">5%   </td><td class="markdownTableBodyNone">Open-source, commercial-friendly    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Maintenance</b>   </td><td class="markdownTableBodyNone">5%   </td><td class="markdownTableBodyNone">Active development, recent updates   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md30"></a>
2.2 Testing Protocol</h2>
<ul>
<li>Prototype development for each candidate</li>
<li>Performance benchmarking on target hardware</li>
<li>Code complexity analysis</li>
<li>Integration difficulty assessment</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md32"></a>
3. Graphics Library Comparison</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
3.1 Candidates Evaluated</h2>
<h3><a class="anchor" id="autotoc_md34"></a>
SFML (Selected *)</h3>
<p><b>Pros:</b></p><ul>
<li>Simple and intuitive API</li>
<li>Excellent documentation</li>
<li>Built-in sprite, texture, and animation management</li>
<li>Cross-platform (Windows, Linux, macOS)</li>
<li>Active community</li>
<li>MIT license</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Limited to 2D graphics</li>
<li>Less performant than raw OpenGL for complex scenes</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average FPS: 300+</div>
<div class="line">Sprite rendering (1000 sprites): 60 FPS stable</div>
<div class="line">Memory usage: ~50MB base</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
SDL2</h3>
<p><b>Pros:</b></p><ul>
<li>Industry standard</li>
<li>Very low-level control</li>
<li>Excellent performance</li>
<li>Wide platform support</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>More verbose API</li>
<li>Requires more boilerplate code</li>
<li>Steeper learning curve</li>
<li>Manual sprite management</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average FPS: 350+</div>
<div class="line">Sprite rendering (1000 sprites): 60 FPS stable</div>
<div class="line">Memory usage: ~40MB base</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36"></a>
Raylib</h3>
<p><b>Pros:</b></p><ul>
<li>Very beginner-friendly</li>
<li>Modern C API</li>
<li>Good performance</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Less mature than SFML/SDL2</li>
<li>Smaller community</li>
<li>Limited advanced features</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average FPS: 280+</div>
<div class="line">Sprite rendering (1000 sprites): 55 FPS</div>
<div class="line">Memory usage: ~45MB base</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
3.2 Decision Matrix</h2>
<p>| Library | Performance | Documentation | Community | Cross-platform | Learning Curve | <b>Total</b> | |------&mdash;|----------&mdash;|------------&mdash;|--------&mdash;|-------------&mdash;|-------------&mdash;|--------&mdash;| | <b>SFML</b> | 8/10 | 10/10 | 9/10 | 9/10 | <b>9.0/10</b> | | SDL2 | 9/10 | 8/10 | 10/10 | 6/10 | <b>8.4/10</b> | | Raylib | 7/10 | 7/10 | 6/10| 10/10 | <b>7.5/10</b> |</p>
<h2><a class="anchor" id="autotoc_md38"></a>
3.3 Final Selection: SFML</h2>
<p><b>Justification</b>: SFML offers the best balance between ease of use and performance for a 2D game. The excellent documentation and straightforward API allowed faster development without sacrificing performance.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md40"></a>
4. Networking Library Comparison</h1>
<h2><a class="anchor" id="autotoc_md41"></a>
4.1 Candidates Evaluated</h2>
<h3><a class="anchor" id="autotoc_md42"></a>
ASIO (Selected *)</h3>
<p><b>Pros:</b></p><ul>
<li>Header-only option available</li>
<li>Excellent async I/O support</li>
<li>UDP and TCP support</li>
<li>Cross-platform</li>
<li>Boost-quality code (standalone version)</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Complex API for beginners</li>
<li>Steep learning curve</li>
<li>Verbose template syntax</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Latency (localhost): ~0.5ms</div>
<div class="line">Throughput: 100K packets/sec</div>
<div class="line">Packet loss handling: Excellent</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md43"></a>
SFML Network Module</h3>
<p><b>Pros:</b></p><ul>
<li>Integrated with SFML</li>
<li>Simple API</li>
<li>Easy to learn</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Limited advanced features</li>
<li>Less control over low-level operations</li>
<li>Blocking operations by default</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Latency (localhost): ~1ms</div>
<div class="line">Throughput: 50K packets/sec</div>
<div class="line">Packet loss handling: Basic</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md44"></a>
4.2 Decision Matrix</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Performance   </th><th class="markdownTableHeadNone">Flexibility   </th><th class="markdownTableHeadNone">Cross-platform   </th><th class="markdownTableHeadNone">Learning Curve   </th><th class="markdownTableHeadNone"><b>Total</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>ASIO</b>   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">5/10   </td><td class="markdownTableBodyNone"><b>9.0/10</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SFML Network   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone"><b>7.5/10</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ENet   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone"><b>7.7/10</b>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md45"></a>
4.3 Final Selection: ASIO</h2>
<p><b>Justification</b>: Despite its complexity, ASIO provides the performance and flexibility needed for real-time multiplayer. The async model is essential for handling multiple clients efficiently.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md47"></a>
5. Entity Component System (ECS) Architecture</h1>
<h2><a class="anchor" id="autotoc_md48"></a>
5.1 Candidates Evaluated</h2>
<h3><a class="anchor" id="autotoc_md49"></a>
Custom ECS (Selected *)</h3>
<p><b>Pros:</b></p><ul>
<li>Full control over design, data layout, and optimization strategies <br  />
</li>
<li>No dependency on external frameworks <br  />
</li>
<li>Can be precisely tailored to the specific gameplay and networking requirements of R-TYPE <br  />
</li>
<li>Educational value: deeper understanding of ECS internals and cache-friendly data organization <br  />
</li>
<li>Simplifies debugging and integration since the entire logic is in-house <br  />
</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Requires more development time <br  />
</li>
<li>Potential for bugs without mature tooling or prior experience <br  />
</li>
<li>Lacks built-in profiling or serialization tools <br  />
</li>
</ul>
<p><b>Performance Metrics (Prototype Implementation):</b> </p><div class="fragment"><div class="line">Entities handled: 10,000+</div>
<div class="line">Component lookup time: ~0.02 ms</div>
<div class="line">System update (average frame): &lt; 0.4 ms</div>
<div class="line">Memory footprint (with 10 systems): ~20 MB</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md51"></a>
EnTT</h3>
<p><b>Pros:</b></p><ul>
<li>Very fast and memory-efficient <br  />
</li>
<li>Mature, actively maintained open-source ECS library <br  />
</li>
<li>Rich API for entity grouping, events, and registry management <br  />
</li>
<li>Proven production use in several games <br  />
</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Complex template-based API <br  />
</li>
<li>Limited debugging visibility (abstraction-heavy) <br  />
</li>
<li>Learning curve for advanced features (views, sparse sets) <br  />
</li>
<li>Adds an external dependency and potential versioning issues <br  />
</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Entities handled: 100,000+</div>
<div class="line">Component lookup time: ~0.01 ms</div>
<div class="line">System update (average frame): &lt; 0.25 ms</div>
<div class="line">Memory footprint: ~25 MB</div>
</div><!-- fragment --><hr  />
<h3><a class="anchor" id="autotoc_md53"></a>
Flecs</h3>
<p><b>Pros:</b></p><ul>
<li>Modern C/C++ hybrid ECS <br  />
</li>
<li>Great introspection and runtime reflection features <br  />
</li>
<li>Built-in profiling, query system, and REST API support <br  />
</li>
<li>Excellent documentation <br  />
</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Slightly heavier runtime footprint <br  />
</li>
<li>Requires adaptation to its architecture (world, modules, pipelines) <br  />
</li>
<li>Less common in C++-only projects compared to EnTT <br  />
</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Entities handled: 80,000+</div>
<div class="line">Component lookup time: ~0.015 ms</div>
<div class="line">System update (average frame): &lt; 0.35 ms</div>
<div class="line">Memory footprint: ~30 MB</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md55"></a>
5.2 Decision Matrix</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">ECS Library   </th><th class="markdownTableHeadNone">Performance   </th><th class="markdownTableHeadNone">Control   </th><th class="markdownTableHeadNone">Ease of Integration   </th><th class="markdownTableHeadNone">Community   </th><th class="markdownTableHeadNone">Learning Curve   </th><th class="markdownTableHeadNone"><b>Total</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Custom ECS</b>   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone"><b>10/10</b>   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone"><b>8.4/10</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">EnTT   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone"><b>8.0/10</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Flecs   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone"><b>7.6/10</b>   </td></tr>
</table>
<hr  />
<h2><a class="anchor" id="autotoc_md57"></a>
5.3 Comparative Analysis</h2>
<p>Compared to traditional <b>Object-Oriented</b> engines (like Unity or Unreal), the ECS model offers:</p><ul>
<li><b>Superior performance</b> through data-oriented design and cache coherence <br  />
</li>
<li><b>Decoupled logic</b>, allowing independent systems to operate on shared data <br  />
</li>
<li><b>Scalability</b> suited for managing thousands of entities efficiently <br  />
</li>
<li><b>Deterministic behavior</b>, ideal for networking and replication in real-time games <br  />
</li>
<li><b>Lightweight footprint</b>, without the overhead of large engine frameworks <br  />
</li>
</ul>
<p>While engines abstract many of these details, ECS provides <b>fine-grained control</b> — essential in a performance-critical, networked project like R-TYPE.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md59"></a>
5.4 Final Selection: Custom ECS</h2>
<p><b>Justification</b>: <br  />
 The custom ECS provides the right balance between control, performance, and educational value. <br  />
 Given R-TYPE’s limited set of components and predictable system interactions, a handcrafted ECS enables direct optimization for memory locality and deterministic updates — crucial for multiplayer synchronization. <br  />
 This choice also avoids unnecessary dependencies and ensures full understanding of internal mechanics for debugging and scaling.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md61"></a>
6. Database Choice for User Management</h1>
<h2><a class="anchor" id="autotoc_md62"></a>
6.1 Candidates Evaluated</h2>
<h3><a class="anchor" id="autotoc_md63"></a>
SQLite (Selected *)</h3>
<p><b>Pros:</b></p><ul>
<li>Lightweight and serverless (no separate database service required)</li>
<li>Zero configuration and minimal setup time</li>
<li>Cross-platform (works identically on Windows, Linux, macOS)</li>
<li>ACID-compliant with strong reliability</li>
<li>Excellent C/C++ API integration</li>
<li>Widely used and tested in production (e.g., Android, Firefox)</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Not suited for large-scale concurrent writes</li>
<li>Limited scalability for distributed systems</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average read latency: 0.3 ms</div>
<div class="line">Average write latency: 0.7 ms</div>
<div class="line">Memory footprint: &lt; 1 MB</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md64"></a>
MySQL</h3>
<p><b>Pros:</b></p><ul>
<li>Excellent scalability for multi-user systems</li>
<li>Mature ecosystem and tools</li>
<li>Supports remote connections and replication</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Requires server setup and configuration</li>
<li>Heavier runtime footprint</li>
<li>Overkill for embedded or local applications</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average read latency: 1.1 ms</div>
<div class="line">Average write latency: 1.5 ms</div>
<div class="line">Memory footprint: ~150 MB (server)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
PostgreSQL</h3>
<p><b>Pros:</b></p><ul>
<li>Advanced SQL features (CTEs, JSON, triggers)</li>
<li>High reliability and ACID compliance</li>
<li>Strong performance for concurrent workloads</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Complex setup and administration</li>
<li>Larger binary and runtime footprint</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Average read latency: 1.0 ms</div>
<div class="line">Average write latency: 1.3 ms</div>
<div class="line">Memory footprint: ~200 MB (server)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
6.2 Decision Matrix</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Database   </th><th class="markdownTableHeadNone">Performance   </th><th class="markdownTableHeadNone">Ease of Integration   </th><th class="markdownTableHeadNone">Scalability   </th><th class="markdownTableHeadNone">Setup Complexity   </th><th class="markdownTableHeadNone"><b>Total</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>SQLite</b>   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone"><b>8.8/10</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">MySQL   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone"><b>7.5/10</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PostgreSQL   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">5/10   </td><td class="markdownTableBodyNone"><b>7.5/10</b>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md67"></a>
6.3 Final Selection: SQLite</h2>
<p><b>Justification:</b> SQLite was chosen due to its <b>lightweight footprint</b>, <b>ease of integration with C++</b>, and <b>zero-configuration</b> nature. For a local or embedded user management system, it provides <b>excellent performance and reliability</b> without the overhead of a server-based database.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md69"></a>
7. Cryptography Library Comparison</h1>
<h2><a class="anchor" id="autotoc_md70"></a>
7.1 Candidates Evaluated</h2>
<h3><a class="anchor" id="autotoc_md71"></a>
libsodium (Selected *)</h3>
<p><b>Pros:</b></p><ul>
<li>Modern, easy-to-use API for encryption, hashing, and key exchange</li>
<li>Cross-platform and battle-tested (used in Signal, Tor, etc.)</li>
<li>High-level abstractions prevent common cryptographic mistakes</li>
<li>Actively maintained and well-documented</li>
<li>BSD license (permissive)</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Slightly larger binary size than minimalistic libraries</li>
<li>Lower-level flexibility limited compared to OpenSSL</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Symmetric encryption: ~1.2 GB/s (AES-GCM)</div>
<div class="line">Key exchange (Curve25519): &lt; 0.5 ms</div>
<div class="line">Memory footprint: ~300 KB</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md72"></a>
OpenSSL</h3>
<p><b>Pros:</b></p><ul>
<li>Industry standard with broad protocol support (TLS, X.509)</li>
<li>Highly configurable and feature-rich</li>
<li>Optimized assembly routines for many CPUs</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Complex and verbose API</li>
<li>Steep learning curve, high chance of misuse</li>
<li>Heavy dependency footprint</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Symmetric encryption: ~1.0 GB/s (AES-GCM)</div>
<div class="line">Key exchange (ECDH): ~0.8 ms</div>
<div class="line">Memory footprint: ~2 MB</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md73"></a>
Crypto++</h3>
<p><b>Pros:</b></p><ul>
<li>Header-only, easy to include in C++ projects</li>
<li>Wide range of algorithms</li>
<li>No external dependencies</li>
</ul>
<p><b>Cons:</b></p><ul>
<li>Documentation less beginner-friendly</li>
<li>Slower updates and smaller community</li>
<li>Less emphasis on misuse resistance</li>
</ul>
<p><b>Performance Metrics:</b> </p><div class="fragment"><div class="line">Symmetric encryption: ~0.8 GB/s</div>
<div class="line">Key exchange (ECDH): ~0.7 ms</div>
<div class="line">Memory footprint: ~400 KB</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md74"></a>
7.2 Decision Matrix</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Performance   </th><th class="markdownTableHeadNone">Ease of Use   </th><th class="markdownTableHeadNone">Security Abstractions   </th><th class="markdownTableHeadNone">Community   </th><th class="markdownTableHeadNone"><b>Total</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>libsodium</b>   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone"><b>9.5/10</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">OpenSSL   </td><td class="markdownTableBodyNone">9/10   </td><td class="markdownTableBodyNone">6/10   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">10/10   </td><td class="markdownTableBodyNone"><b>8.3/10</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Crypto++   </td><td class="markdownTableBodyNone">8/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone">7/10   </td><td class="markdownTableBodyNone"><b>7.3/10</b>   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md75"></a>
7.3 Final Selection: libsodium</h2>
<p><b>Justification:</b> libsodium provides a <b>secure-by-default</b>, <b>cross-platform</b>, and <b>developer-friendly</b> cryptographic toolkit. Its modern API design minimizes implementation errors while offering strong performance and portability — making it ideal for applications requiring <b>data integrity and confidentiality</b> without unnecessary complexity.</p>
<h1><a class="anchor" id="autotoc_md76"></a>
8. Configuration Management</h1>
<h2><a class="anchor" id="autotoc_md77"></a>
8.1 Library Choice: libconfig++</h2>
<p>To handle configuration data (such as entity definitions, levels, or tuning parameters), the project uses <b>libconfig++</b>, a lightweight, structured configuration file parser and writer for C++.</p>
<h3><a class="anchor" id="autotoc_md78"></a>
Example Level Configuration File</h3>
<p>entities = ( { name = "red_trooper"; spawn_time = 3.0; y = 50.0; }, { name = "walker"; spawn_time = 5.0; y = 150.0; }, { name = "red_trooper"; spawn_time = 7.0; y = 50.0; } );</p>
<p>This process runs once per level load and populates the ECS with predefined entities.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md80"></a>
8.2 Integration and Workflow Benefits</h2>
<ul>
<li><b>Data-Driven Design:</b> Core game logic is separated from static data, enabling non-programmers to modify levels or tuning values. <br  />
</li>
<li><b>Hot Reloading:</b> Configuration files can be reloaded at runtime for rapid testing. <br  />
</li>
<li><b>Cross-Platform Portability:</b> libconfig++ works on Linux, macOS, and Windows without additional dependencies. <br  />
</li>
<li><b>Version Control Friendly:</b> Since files are plain text, they merge easily in Git and can be diffed without binary conflicts.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md82"></a>
8.3 Summary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Criterion   </th><th class="markdownTableHeadNone">libconfig++   </th><th class="markdownTableHeadNone">JSON   </th><th class="markdownTableHeadNone">YAML   </th><th class="markdownTableHeadNone">XML   </th><th class="markdownTableHeadNone">INI    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Human-readability   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">⚠️ Verbose   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Hierarchical data   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Comments support   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">❌   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C++ type safety   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">⚠️ Manual casts   </td><td class="markdownTableBodyNone">⚠️ Manual casts   </td><td class="markdownTableBodyNone">⚠️ Manual casts   </td><td class="markdownTableBodyNone">✅ (limited)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Performance   </td><td class="markdownTableBodyNone">✅   </td><td class="markdownTableBodyNone">⚠️ Moderate   </td><td class="markdownTableBodyNone">⚠️ Slow   </td><td class="markdownTableBodyNone">⚠️ Slow   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dependency overhead   </td><td class="markdownTableBodyNone">✅ Minimal   </td><td class="markdownTableBodyNone">⚠️ Header-only   </td><td class="markdownTableBodyNone">⚠️ External   </td><td class="markdownTableBodyNone">⚠️ External   </td><td class="markdownTableBodyNone">✅ Minimal   </td></tr>
</table>
<p><b>Final Decision:</b> <br  />
 libconfig++ provides the <b>best trade-off</b> between readability, speed, and ease of integration for a C++ ECS-based game engine where configurations are frequently loaded and modified.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
9. Testing Framework</h1>
<h2><a class="anchor" id="autotoc_md84"></a>
9.1 Library Choice: Google Test (gtest)</h2>
<p>For unit testing, the project uses <b>Google Test (gtest)</b>, a widely adopted C++ testing framework that provides a robust and feature-rich environment for writing automated tests.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md86"></a>
9.2 Advantages of Google Test</h2>
<ol type="1">
<li><b>Comprehensive Testing Features</b> <br  />
<ul>
<li>Supports <b>unit tests</b>, <b>integration tests</b>, and <b>mocking</b> (with gmock). <br  />
</li>
<li>Provides a rich set of assertions (<code>EXPECT_EQ</code>, <code>ASSERT_TRUE</code>, <code>EXPECT_NEAR</code>, etc.) for numeric, string, and container comparisons.</li>
</ul>
</li>
<li><b>C++ Native and Type-Safe</b> <br  />
<ul>
<li>Fully integrates with C++ type system, supporting templates and complex data structures. <br  />
</li>
<li>Eliminates the need for wrapper functions or C-style test cases.</li>
</ul>
</li>
<li><b>Test Fixtures</b> <br  />
<ul>
<li>Supports <b>test fixtures</b>, allowing setup and teardown for multiple tests sharing the same environment or objects. <br  />
</li>
<li>Reduces code duplication and ensures consistent test initialization.</li>
</ul>
</li>
<li><b>Integration with Build Systems</b> <br  />
<ul>
<li>Easily integrates with <b>CMake</b>, <b>Makefiles</b>, or IDEs like CLion and Visual Studio. <br  />
</li>
<li>Tests can be run automatically as part of CI/CD pipelines.</li>
</ul>
</li>
<li><b>Cross-Platform</b> <br  />
<ul>
<li>Works on <b>Linux, Windows, and macOS</b>. <br  />
</li>
<li>Consistent API and output format across platforms.</li>
</ul>
</li>
<li><b>Readable Output and Debugging</b> <br  />
<ul>
<li>Provides <b>colorized console output</b> for pass/fail results. <br  />
</li>
<li>Includes detailed information on failed assertions and stack traces. <br  />
</li>
<li>Supports <b>filtering tests</b> and running subsets of test suites.</li>
</ul>
</li>
<li><b>Active Community and Documentation</b> <br  />
<ul>
<li>Extensive tutorials, example projects, and active community support. <br  />
</li>
<li>Well-maintained and updated to modern C++ standards.</li>
</ul>
</li>
</ol>
<hr  />
<h2><a class="anchor" id="autotoc_md88"></a>
9.3 Example Test Case</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;gtest/gtest.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ecs.h&quot;</span></div>
<div class="line"> </div>
<div class="line">TEST(ECSComponentTest, AddAndRetrieveComponent) {</div>
<div class="line">    ECS ecs;</div>
<div class="line">    Entity e = ecs.createEntity();</div>
<div class="line"> </div>
<div class="line">    ecs.addComponent&lt;Position&gt;(e, {10.0f, 20.0f});</div>
<div class="line">    <span class="keyword">auto</span> pos = ecs.getComponent&lt;Position&gt;(e);</div>
<div class="line"> </div>
<div class="line">    ASSERT_TRUE(pos.has_value());</div>
<div class="line">    EXPECT_EQ(pos-&gt;x, 10.0f);</div>
<div class="line">    EXPECT_EQ(pos-&gt;y, 20.0f);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h2><a class="anchor" id="autotoc_md90"></a>
9.4 Why Google Test Was Selected</h2>
<ul>
<li><b>Standard in C++ development</b>: widely used and well-documented. <br  />
</li>
<li><b>Scalable for large projects</b>: easily handles hundreds of test cases and multiple modules. <br  />
</li>
<li><b>Compatibility with ECS</b>: tests can verify entity creation, component addition/removal, and system updates. <br  />
</li>
<li><b>Supports continuous integration</b>: automated testing is crucial for multiplayer game reliability.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md92"></a>
9.5 Summary</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Criterion   </th><th class="markdownTableHeadNone">Google Test   </th><th class="markdownTableHeadNone">Alternatives (Catch2, Boost.Test)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Feature Completeness   </td><td class="markdownTableBodyNone">✅ Full-featured   </td><td class="markdownTableBodyNone">✅ Good (Catch2), ⚠️ Heavy (Boost.Test)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Cross-platform   </td><td class="markdownTableBodyNone">✅ Linux, Windows, macOS   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Ease of Integration   </td><td class="markdownTableBodyNone">✅ CMake, CI/CD   </td><td class="markdownTableBodyNone">✅    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Mocking Support   </td><td class="markdownTableBodyNone">✅ via gmock   </td><td class="markdownTableBodyNone">⚠️ Limited or requires extra library    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Documentation &amp; Community   </td><td class="markdownTableBodyNone">✅ Large   </td><td class="markdownTableBodyNone">✅ Moderate   </td></tr>
</table>
<p><b>Final Decision:</b> Google Test offers the most <b>robust, flexible, and widely adopted framework</b> for C++ unit testing, making it ideal for ensuring correctness in R-TYPE’s ECS-based architecture.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
10. Algorithms, Data Structures and Design Patterns</h2>
<p>The choices in this section aim to balance <b>performance</b>, <b>simplicity</b>, and <b>code maintainability</b> in the Entity-Component-System (ECS) architecture and its client-server synchronization logic.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md95"></a>
Core Structures</h3>
<ul>
<li><p class="startli">**<code>std::vector&lt;std::optional&lt;T&gt;&gt;</code> for ECS components**</p>
<p class="startli">This structure allows efficient storage of components associated with entities. <br  />
 Using <code>std::optional</code> provides direct index-based access while supporting empty slots (for deleted or missing entities) without requiring explicit identifiers. <br  />
 This design reduces memory overhead, avoids redundant entity IDs, and keeps data contiguous in memory — significantly improving cache locality and sequential access performance.</p>
</li>
<li><p class="startli">**<code>std::unordered_map</code> for component table storage**</p>
<p class="startli">Component tables are stored in <code>std::unordered_map</code> containers to provide amortized constant-time (<code>O(1)</code>) access for insertion, lookup, and removal. <br  />
 This is ideal for ECS systems where direct access patterns dominate, as it minimizes CPU cache misses. <br  />
 An alternative would be <code>std::map</code> (a balanced binary tree), but it introduces logarithmic complexity (<code>O(log n)</code>), which is unnecessary in most real-time systems.</p>
</li>
</ul>
<hr  />
<h3><a class="anchor" id="autotoc_md97"></a>
Client-side Change Detection Algorithm</h3>
<p>When a client receives a <b>snapshot</b> from the server (a complete or partial state of all entities), it must determine:</p><ul>
<li>which entities are <b>new</b> (present in the snapshot but not locally),</li>
<li>which entities are <b>deleted</b> (missing from the snapshot but still locally stored),</li>
<li>and which entities must be <b>updated</b> (present in both but with changed components).</li>
</ul>
<p>To achieve this efficiently, a <b>hashmap-based diff detection algorithm</b> is used:</p><ul>
<li>Each entity is indexed by its unique identifier (<code>entity_id</code>).</li>
<li>The client maintains a local dictionary (<code>unordered_map&lt;entity_id, EntitySnapshot&gt;</code>).</li>
<li>When a new snapshot arrives:<ul>
<li>The snapshot is iterated to detect <b>new or modified</b> entities by comparing component hashes against the local version.</li>
<li>The local state is then scanned to identify <b>removed</b> entities missing from the new snapshot.</li>
</ul>
</li>
</ul>
<p>This approach yields an average complexity of <b>O(n)</b> (linear with the number of exchanged entities), which performs efficiently under real-time update conditions, even with frequent incremental changes.</p>
<hr  />
<h3><a class="anchor" id="autotoc_md99"></a>
Design Pattern: Factory for Entity Creation</h3>
<p>To centralize and standardize entity creation in the ECS, a <b>Factory pattern</b> is used. <br  />
 The <code>Factory</code> class encapsulates the logic required to create different types of entities (players, enemies, projectiles, etc.) with their respective components, ensuring consistency and modularity across the codebase.</p>
<p>Example — creating a player entity:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classentity.html">entity</a> Factory::make_player1() {</div>
<div class="line">    <a class="code hl_class" href="classentity.html">entity</a> player_id = reg.spawn_entity();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>&amp; player_sprite = reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1drawable__s.html">component::drawable</a>&gt;(</div>
<div class="line">        player_id, <a class="code hl_typedef" href="namespacecomponent.html#afaa0e7d53a27314c39fd8984cd068895">component::drawable</a>()</div>
<div class="line">    );</div>
<div class="line">    player_sprite.<a class="code hl_function" href="structcomponent_1_1drawable__s.html#a7ee88f7aa48fd311461240b86f0db87a">setTextureFromName</a>(<span class="stringliteral">&quot;player1&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1position__s.html">component::position</a>&gt;(player_id, {0, 0});</div>
<div class="line">    reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1velocity__s.html">component::velocity</a>&gt;(player_id, {0, 0});</div>
<div class="line">    reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1controllable__s.html">component::controllable</a>&gt;(</div>
<div class="line">        player_id, <a class="code hl_typedef" href="namespacecomponent.html#ac85f4762db6e1c119b13fedc4f9c157c">component::controllable</a>()</div>
<div class="line">    );</div>
<div class="line">    reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1logic__s.html">component::logic</a>&gt;(</div>
<div class="line">        player_id, <a class="code hl_struct" href="structcomponent_1_1logic__s.html">component::logic</a>{player_logic}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>&amp; player_hurtbox =</div>
<div class="line">        reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1hurtbox__s.html">component::hurtbox</a>&gt;(player_id, <a class="code hl_typedef" href="namespacecomponent.html#a00cb098de199eed73e38d77f78adaed1">component::hurtbox</a>());</div>
<div class="line">    player_hurtbox.group = 1;</div>
<div class="line">    player_hurtbox.health = 1;</div>
<div class="line">    player_hurtbox.width = 32;</div>
<div class="line">    player_hurtbox.height = 16;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span>&amp; entity_name = reg.add_component&lt;<a class="code hl_struct" href="structcomponent_1_1name__s.html">component::name</a>&gt;(</div>
<div class="line">        player_id, <a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">component::name</a>()</div>
<div class="line">    );</div>
<div class="line">    entity_name.<a class="code hl_variable" href="structcomponent_1_1name__s.html#a7d824b9f299f3dc86b247d2cb3b56fde">_name</a> = <span class="stringliteral">&quot;player1&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    reg.add_component&lt;<a class="code hl_typedef" href="namespacecomponent.html#a9d008508800cc3ed05b1794c9569a86e">component::unique_id</a>&gt;(</div>
<div class="line">        player_id, (<a class="code hl_typedef" href="namespacecomponent.html#a9d008508800cc3ed05b1794c9569a86e">component::unique_id</a>)<a class="code hl_variable" href="components_8hpp.html#ac2619880da23ee8b66a14cb027d07c98">unique_ids</a></div>
<div class="line">    );</div>
<div class="line">    <a class="code hl_variable" href="components_8hpp.html#ac2619880da23ee8b66a14cb027d07c98">unique_ids</a>++;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> player_id;</div>
<div class="line">}</div>
<div class="ttc" id="aclassentity_html"><div class="ttname"><a href="classentity.html">entity</a></div><div class="ttdoc">The entity class, defined by an id to which components will be associated.</div><div class="ttdef"><b>Definition</b> entity.hpp:40</div></div>
<div class="ttc" id="acomponents_8hpp_html_ac2619880da23ee8b66a14cb027d07c98"><div class="ttname"><a href="components_8hpp.html#ac2619880da23ee8b66a14cb027d07c98">unique_ids</a></div><div class="ttdeci">int unique_ids</div></div>
<div class="ttc" id="anamespacecomponent_html_a00cb098de199eed73e38d77f78adaed1"><div class="ttname"><a href="namespacecomponent.html#a00cb098de199eed73e38d77f78adaed1">component::hurtbox</a></div><div class="ttdeci">struct component::hurtbox_s hurtbox</div><div class="ttdoc">The hurtbox component, defined by a size, health and a group (1 for the player, 2 for the enemies for...</div></div>
<div class="ttc" id="anamespacecomponent_html_a9d008508800cc3ed05b1794c9569a86e"><div class="ttname"><a href="namespacecomponent.html#a9d008508800cc3ed05b1794c9569a86e">component::unique_id</a></div><div class="ttdeci">int unique_id</div><div class="ttdoc">The unique_id component, defined by an int. It lets you give a unique id to each entity.</div><div class="ttdef"><b>Definition</b> components.hpp:360</div></div>
<div class="ttc" id="anamespacecomponent_html_ac85f4762db6e1c119b13fedc4f9c157c"><div class="ttname"><a href="namespacecomponent.html#ac85f4762db6e1c119b13fedc4f9c157c">component::controllable</a></div><div class="ttdeci">struct component::controllable_s controllable</div><div class="ttdoc">The controllable component, defined by a set of booleans. This component allows an entity to be contr...</div></div>
<div class="ttc" id="anamespacecomponent_html_af42f87bf296e95960edc1d8eb0ea059b"><div class="ttname"><a href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">component::name</a></div><div class="ttdeci">struct component::name_s name</div><div class="ttdoc">The name component, defined by a string. It lets you give a name to each entity.</div></div>
<div class="ttc" id="anamespacecomponent_html_afaa0e7d53a27314c39fd8984cd068895"><div class="ttname"><a href="namespacecomponent.html#afaa0e7d53a27314c39fd8984cd068895">component::drawable</a></div><div class="ttdeci">struct component::drawable_s drawable</div><div class="ttdoc">The drawable component, defined by an sf::Sprite. This component allows an entity to be drawn on the ...</div></div>
<div class="ttc" id="astructcomponent_1_1controllable__s_html"><div class="ttname"><a href="structcomponent_1_1controllable__s.html">component::controllable_s</a></div><div class="ttdoc">The controllable component, defined by a set of booleans. This component allows an entity to be contr...</div><div class="ttdef"><b>Definition</b> components.hpp:184</div></div>
<div class="ttc" id="astructcomponent_1_1drawable__s_html"><div class="ttname"><a href="structcomponent_1_1drawable__s.html">component::drawable_s</a></div><div class="ttdoc">The drawable component, defined by an sf::Sprite. This component allows an entity to be drawn on the ...</div><div class="ttdef"><b>Definition</b> components.hpp:82</div></div>
<div class="ttc" id="astructcomponent_1_1drawable__s_html_a7ee88f7aa48fd311461240b86f0db87a"><div class="ttname"><a href="structcomponent_1_1drawable__s.html#a7ee88f7aa48fd311461240b86f0db87a">component::drawable_s::setTextureFromName</a></div><div class="ttdeci">void setTextureFromName(std::string texture_name)</div><div class="ttdoc">This function uses a ResourceManager to set the texture of the sprite.</div><div class="ttdef"><b>Definition</b> components.hpp:92</div></div>
<div class="ttc" id="astructcomponent_1_1hurtbox__s_html"><div class="ttname"><a href="structcomponent_1_1hurtbox__s.html">component::hurtbox_s</a></div><div class="ttdoc">The hurtbox component, defined by a size, health and a group (1 for the player, 2 for the enemies for...</div><div class="ttdef"><b>Definition</b> components.hpp:252</div></div>
<div class="ttc" id="astructcomponent_1_1logic__s_html"><div class="ttname"><a href="structcomponent_1_1logic__s.html">component::logic_s</a></div><div class="ttdoc">The logic component, defined by a function pointer. This component allows an entity to have a logic d...</div><div class="ttdef"><b>Definition</b> components.hpp:325</div></div>
<div class="ttc" id="astructcomponent_1_1name__s_html"><div class="ttname"><a href="structcomponent_1_1name__s.html">component::name_s</a></div><div class="ttdoc">The name component, defined by a string. It lets you give a name to each entity.</div><div class="ttdef"><b>Definition</b> components.hpp:341</div></div>
<div class="ttc" id="astructcomponent_1_1name__s_html_a7d824b9f299f3dc86b247d2cb3b56fde"><div class="ttname"><a href="structcomponent_1_1name__s.html#a7d824b9f299f3dc86b247d2cb3b56fde">component::name_s::_name</a></div><div class="ttdeci">std::string _name</div><div class="ttdef"><b>Definition</b> components.hpp:342</div></div>
<div class="ttc" id="astructcomponent_1_1position__s_html"><div class="ttname"><a href="structcomponent_1_1position__s.html">component::position_s</a></div><div class="ttdoc">The position component, with an x and y position.</div><div class="ttdef"><b>Definition</b> components.hpp:50</div></div>
<div class="ttc" id="astructcomponent_1_1velocity__s_html"><div class="ttname"><a href="structcomponent_1_1velocity__s.html">component::velocity_s</a></div><div class="ttdoc">The velocity component, with an x and y velocity. This component allows an entity to move.</div><div class="ttdef"><b>Definition</b> components.hpp:72</div></div>
</div><!-- fragment --><p>This approach provides several advantages:</p><ul>
<li><b>Encapsulation of complexity</b> — entity construction logic (and component dependencies) is hidden from the rest of the system. <br  />
</li>
<li><b>Consistency</b> — all entities of the same type are guaranteed to have the same component configuration. <br  />
</li>
<li><b>Maintainability</b> — new entity types can be added without modifying the ECS core. <br  />
</li>
<li><b>Scalability</b> — different factories can be defined for gameplay modules (e.g., player, enemies, projectiles, bosses).</li>
</ul>
<p>An alternative approach could be to define entities through <b>configuration files</b> or <b>prefabs</b>, but using a factory allows better compile-time safety and avoids runtime parsing overhead during gameplay.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md101"></a>
11. Risk Assessment</h1>
<h2><a class="anchor" id="autotoc_md102"></a>
11.1 Technical Risks</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Risk   </th><th class="markdownTableHeadNone">Probability   </th><th class="markdownTableHeadNone">Impact   </th><th class="markdownTableHeadNone">Mitigation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ASIO learning curve delays development   </td><td class="markdownTableBodyNone">Medium   </td><td class="markdownTableBodyNone">Medium   </td><td class="markdownTableBodyNone">Early prototyping, pair programming    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Custom ECS bugs   </td><td class="markdownTableBodyNone">Medium   </td><td class="markdownTableBodyNone">High   </td><td class="markdownTableBodyNone">Comprehensive unit tests, code reviews    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Network latency issues   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">High   </td><td class="markdownTableBodyNone">Client-side prediction, lag compensation    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">SFML performance bottlenecks   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Medium   </td><td class="markdownTableBodyNone">Profiling, optimization passes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Dependency management complexity   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Low   </td><td class="markdownTableBodyNone">Conan package manager   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md103"></a>
11.2 Alternative Plans</h2>
<p>If critical issues arise:</p><ul>
<li><b>ASIO → SFML Network</b>: Simpler but less performant</li>
<li><b>Custom ECS → EnTT</b>: More mature but additional dependency</li>
<li><b>SFML → SDL2</b>: More control but more development time</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md105"></a>
12. Conclusion</h1>
<h2><a class="anchor" id="autotoc_md106"></a>
12.1 Key Takeaways</h2>
<h2><a class="anchor" id="autotoc_md107"></a>
12.2 Lessons Learned</h2>
<ul>
<li>Prototype-driven evaluation is essential for informed decisions</li>
<li>Performance benchmarks must be conducted on target hardware</li>
<li>Documentation quality significantly impacts development velocity</li>
<li>Community support is crucial for troubleshooting</li>
<li>Balance between "best" and "good enough" is critical</li>
</ul>
<h2><a class="anchor" id="autotoc_md108"></a>
12.3 Future Considerations</h2>
<hr  />
<h1><a class="anchor" id="autotoc_md110"></a>
13. Appendices</h1>
<ul>
<li>SFML Documentation: <a href="https://www.sfml-dev.org/documentation/">https://www.sfml-dev.org/documentation/</a></li>
<li>ASIO Documentation: <a href="https://think-async.com/Asio/">https://think-async.com/Asio/</a></li>
<li>Google Test Documentation: <a href="https://google.github.io/googletest/">https://google.github.io/googletest/</a></li>
<li>Game Programming Patterns: <a href="https://gameprogrammingpatterns.com/">https://gameprogrammingpatterns.com/</a></li>
<li>LibSodium Documentation: <a href="https://libsodium.gitbook.io/doc">https://libsodium.gitbook.io/doc</a></li>
<li>Sqlite3 Documentation: <a href="https://www.sqlite.org/docs.html">https://www.sqlite.org/docs.html</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md111"></a>
Appendix E: Team Contributions</h2>
<p>| Team Member | Role | Contribution | |----------&mdash;|---&mdash;|-----------&mdash;| | [Farouk_OKANLA] | | [Oscar_GBENOU] | | [Aïmane_ALASSANE] | | [Philippe_ABIODOUN] | | [Amour_GUIDI] |</p>
<hr  />
<p><b>Document Version</b>: 1.0 <br  />
 <b>Last Updated</b>: [12/10/2025] <br  />
 <b>Authors</b>: [Cold_As_Palmer] <br  />
 <b>Review Status</b>: [Review] </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
