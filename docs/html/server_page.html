<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R-TYPE: R-TYPE Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">R-TYPE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">R-TYPE Server</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page details how the server works.</p>
<h1><a class="anchor" id="global_infos"></a>
Global Explanation</h1>
<p>The server is responsible of holding the actual state of the game and transferring it to the clients. The game scene, with the players, the ennemies or their projectiles takes place in the registry inside the server.</p>
<h1><a class="anchor" id="game_logic"></a>
Game Logic</h1>
<p>The server handles all the game logic. It starts by loading a configuration file containing all infos about the level : What ennemies will spawn ? Where ? When ?</p>
<div class="fragment"><div class="line">*entities = (</div>
<div class="line">    {name = <span class="stringliteral">&quot;red_trooper&quot;</span>; spawn_time = 3.4; y = 50.0;},</div>
<div class="line">    {name = <span class="stringliteral">&quot;red_trooper&quot;</span>; spawn_time = 3.8; y = 50.0;},</div>
<div class="line">    {<a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">name</a> = <span class="stringliteral">&quot;red_trooper&quot;</span>; spawn_time = 4.2; y = 50.0;},</div>
<div class="line">    {<a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">name</a> = <span class="stringliteral">&quot;red_trooper&quot;</span>; spawn_time = 4.6; y = 50.0;},</div>
<div class="line"> </div>
<div class="line">    {<a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">name</a> = <span class="stringliteral">&quot;walker&quot;</span>; spawn_time = 5.0; y = 367.0;},</div>
<div class="line">    {<a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">name</a> = <span class="stringliteral">&quot;red_trooper&quot;</span>; spawn_time = 7.0; y = 50.0;},</div>
<div class="line">    {<a class="code hl_typedef" href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">name</a> = <span class="stringliteral">&quot;boss&quot;</span>; spawn_time = 10.0; y = 150.0;}</div>
<div class="line"> );</div>
<div class="ttc" id="anamespacecomponent_html_af42f87bf296e95960edc1d8eb0ea059b"><div class="ttname"><a href="namespacecomponent.html#af42f87bf296e95960edc1d8eb0ea059b">component::name</a></div><div class="ttdeci">struct component::name_s name</div><div class="ttdoc">The name component, defined by a string. It lets you give a name to each entity.</div></div>
</div><!-- fragment --><p>During the game, it then spawns the entities at the correct moment. Thanks to the logic components and the logic system as well as all the other ones. The entities evolve in the scene. All the server has to do now is to go through each game entity (and skip special ones like the background, the music) and send its infos (type and position) to each client. See more in <a class="el" href="level__handling_8cpp.html">level_handling.cpp</a>.</p>
<p>Simultaneously, the server listens to inputs from the clients If an input is received, the server then applies velocity to the corresponding player entity.</p>
<h1><a class="anchor" id="network_details"></a>
Network Details</h1>
<p>When the server starts, it call a <code>NetworkManager</code> that listens for incoming UDP packets from clients:</p>
<div class="fragment"><div class="line">Server::Server(<span class="keywordtype">int</span> p, <a class="code hl_class" href="classregistry.html">registry</a>&amp; regis)</div>
<div class="line">    : server_(p, std::ref(messages), std::ref(mtx)), p_(p), reg(regis)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="init__gameInstance_8cpp.html#a0c588e2ccf2ed315e2710776feac9eff">load_textures</a>();</div>
<div class="line">    initializeGame();</div>
<div class="line">    loadLevel(<span class="stringliteral">&quot;assets/levels/test.txt&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="aclassregistry_html"><div class="ttname"><a href="classregistry.html">registry</a></div><div class="ttdoc">The registry class. The registry is a container for all the entities and components of the game....</div><div class="ttdef"><b>Definition</b> registry.hpp:63</div></div>
<div class="ttc" id="ainit__gameInstance_8cpp_html_a0c588e2ccf2ed315e2710776feac9eff"><div class="ttname"><a href="init__gameInstance_8cpp.html#a0c588e2ccf2ed315e2710776feac9eff">load_textures</a></div><div class="ttdeci">void load_textures(void)</div><div class="ttdoc">This function uses the ResourceManager to pre-load textures and fonts that will be used in the game.</div><div class="ttdef"><b>Definition</b> init_gameInstance.cpp:26</div></div>
</div><!-- fragment --><p>The constructor of <code>NetworkManager</code> creates a UDP socket bind to the given port and starts an asynchronous loop:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NetworkManager::receive_from_clients();</div>
</div><!-- fragment --><p>This allows the server to receive messages (typically player inputs) from all connected clients.</p>
<p>A client sends a UDP packet, the server receives it via:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NetworkManager::receive_from_clients();</div>
</div><!-- fragment --><p>Inside the callback:</p><ul>
<li>The sender’s endpoint (<code>last_sender_</code>) is stored.</li>
<li>The received bytes are appended into the shared buffer <code>clients_lastmsg</code> (a vector of endpoint–message pairs).</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line">clients_lastmsg.push_back({</div>
<div class="line">    last_sender_,</div>
<div class="line">    std::vector&lt;int8_t&gt;(buff.begin(), buff.begin() + bytes_receive)</div>
<div class="line">});</div>
</div><!-- fragment --><p>This data is protected by a mutex (<code>std::lock_guard&lt;std::mutex&gt; lock(mtx)</code>) to ensure thread safety while other threads process it.</p>
<p>After each update cycle, the server recup the current state of all entities (positions, types, health, etc.) and sends this information to each connected client using:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NetworkManager::send_to_client(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;int8_t&gt;&amp; msg,</div>
<div class="line">    <span class="keywordtype">size_t</span> size,</div>
<div class="line">    <span class="keyword">const</span> asio::ip::udp::endpoint&amp; to_client</div>
<div class="line">);</div>
</div><!-- fragment --><p>The communication is <b>asynchronous</b>, ensuring that no blocking occurs during gameplay. Each message represents a <b>snapshot of the current world state</b>.</p>
<p>The server uses a <b>multi-threaded</b> architecture:</p><ul>
<li>The main thread runs the <b>SFML window</b>, updates the registry, runs systems, and advances the level logic.</li>
<li>A separate <b>ASIO thread</b> executes the I/O context (<code>context.run()</code>), handling all network communications asynchronously.</li>
</ul>
<p>Synchronization between threads is done using <code>std::mutex</code> objects, which protect shared message buffers:</p><ul>
<li><code>clients_lastmsg</code>: stores last messages from all clients,</li>
<li><code>messages</code>: stores data ready to be broadcast.</li>
</ul>
<div class="fragment"><div class="line">std::thread t([&amp;c]() { c.run(); });</div>
</div><!-- fragment --><p>When the game ends (e.g., boss defeated or all players dead), the SFML window closes, and the ASIO context is stopped:</p>
<div class="fragment"><div class="line">c.getContext().stop();</div>
<div class="line">t.join();</div>
</div><!-- fragment --><p>This ensures all asynchronous operations are safely terminated.</p>
<ul>
<li>Protocol: <b>UDP</b></li>
<li>Library: <b>ASIO</b></li>
<li>Asynchronous communication (non-blocking) </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
